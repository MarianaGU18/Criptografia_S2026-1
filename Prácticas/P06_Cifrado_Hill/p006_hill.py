# -*- coding: utf-8 -*-
"""P006_Hill.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-FvoDH3BVF-TFTjoi1I1AoKGX5kAIDRf
"""

# llaves
# llave de 5x5

keys= {
    5:[
        [3, 10, 20, 11, 5],
        [2, 5, 9, 4, 17],
        [3, 20, 17, 9, 8],
        [4, 9, 11, 7, 14],
        [5, 2, 3, 8, 6]
    ],
    6: [
        [ 3, 10, 21,  3, 10, 14],
        [ 3,  7, 23, 15, 15,  6],
        [ 5, 17, 25,  1, 15,  1],
        [ 7,  1, 24,  4, 21, 12],
        [ 8, 19, 16, 19,  7, 16],
        [11,  3,  4,  8, 12, 17]
    ],
    7: [
        [21,  3, 12,  1,  8,  0,  1],
        [17,  0, 20,  0, 23, 14,  3],
        [24, 17, 11,  7, 12, 16, 13],
        [ 9,  0, 17, 24, 14, 19,  1],
        [ 0,  5, 21, 19, 11,  3, 19],
        [16, 13, 17, 16,  7, 10, 11],
        [ 4,  8, 22, 25,  4,  0, 14]
    ]

}


MOD = 26
#funcion para convertir un caracter a su valor numero tomando como base los valores de ASCII
def char_to_num(c): return ord(c.upper()) - ord('A')
#funcion para convertir un valor númerico a caracter tomando como base los valores de ASCII
def num_to_char(n): return chr((n % MOD) + ord('A'))


#convierte el mensaje en valores numericos
#devuelve una lista de listas en donde cada elemento corresponde a un vector de tamaño n-grama
def text_to_array(message,blockSize):
    numbers = [char_to_num(c) for c in message if c.isalpha()]
    while len(numbers) % blockSize != 0:
        numbers.append(char_to_num('X'))
    return [numbers[i:i+blockSize] for i in range(0, len(numbers), blockSize)]


#convierte un vector de número a su equivalente en letras
def vector_to_text(vectors):
    return ''.join(num_to_char(n) for vec in vectors for n in vec)


# Calcula el determinante de la matriz por el método de cofactores
def get_minor(matrix, i, j):
    return [row[:j] + row[j+1:] for idx, row in enumerate(matrix) if idx != i]

def determinant(matrix):
    size = len(matrix)
    if size == 1:
        return matrix[0][0]
    if size == 2:
        return matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0]
    det = 0
    for j in range(size):
        sign = (-1) ** j
        minor = get_minor(matrix, 0, j)
        det += sign * matrix[0][j] * determinant(minor)
    return det

# calcula el cofactor de la matriz
def cofactor_matrix(matrix):
    size = len(matrix)
    cofactors = []
    for i in range(size):
        row = []
        for j in range(size):
            minor = get_minor(matrix, i, j)
            sign = (-1) ** (i + j)
            row.append(sign * determinant(minor))
        cofactors.append(row)
    return cofactors

# calcula la matriz traspuesta
def transpose(matrix):
    return [list(row) for row in zip(*matrix)]

# calcula la matriz adjunta
def adjugate(matrix):
    return transpose(cofactor_matrix(matrix))

# calcula la inversa modular
def mod_inverse(a, mod):
    for x in range(1, mod):
        if (a * x) % mod == 1:
            return x
    raise ValueError(f"No inverse for {a} mod {mod}")

def matrix_mod_inverse(matrix, mod):
    det = determinant(matrix) % mod
    try:
        det_inv = mod_inverse(det, mod)
    except ValueError:
        raise ValueError(f"La matriz no tiene inversa módulo {mod}. Determinante = {det}")
    adj = adjugate(matrix)
    return [[(det_inv * elem) % mod for elem in row] for row in adj]



# hace la multiplicacion de vector por la matriz que representa la llave
def encrypt_block(block, key_matrix):
    return [sum(block[j] * key_matrix[i][j] for j in range(len(block))) % MOD for i in range(len(key_matrix))]

# hace la multiplicacion de vector por la matriz que representa la inversa de la llave
def decrypt_block(block, inv_key_matrix):
    return [sum(block[j] * inv_key_matrix[i][j] for j in range(len(block))) % MOD for i in range(len(inv_key_matrix))]



#función de cifrado Hill
def encrypt(text, key):
    blocks = text_to_array(text, len(key))
    return vector_to_text([encrypt_block(block, key) for block in blocks])

#criptoanalisis de Hill
def decrypt(cipher, key):
    inv_key = matrix_mod_inverse(key, MOD)
    blocks = text_to_array(cipher, len(key))
    return vector_to_text([decrypt_block(block, inv_key) for block in blocks])



def menu():
    print("-----SELECCCIONA EL TAMAÑO DE LA CLAVE--------")
    while True:
        try:
            block_size = int(input("Selecciona tamaño de bloque (5, 6 o 7): "))
            if block_size in keys:
                break
            else:
                print("Tamaño no válido. Elige 5, 6 o 7.")
        except ValueError:
            print("Entrada inválida. Escribe un número.")

    # Solicita mensaje
    message = input("Escribe el mensaje a cifrar: ").upper()
    key = keys[block_size]
    cipher = encrypt(message,key)
    cryptanalysis = decrypt(cipher,key)
    print('Texto original ',message)
    print('Texto cifrado: ', cipher)
    print('Aplicando criptoanalisis:', cryptanalysis)


menu()