# -*- coding: utf-8 -*-
"""vigenereKasiski

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1S2ChbRkbBtzBVDzREoDjzXS3d5U_zdX2
"""

#!/usr/bin/env python3
# vigenere.py
# Conversión a Python del cifrado Vigenère (basado en el archivo original subido).

ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
ALPHABET_LEN = len(ALPHABET)

def index_of(c: str) -> int:
    """Devuelve índice en ALPHABET para la letra c (ignora case). -1 si no es letra A-Z."""
    uc = c.upper()
    return ALPHABET.find(uc)

def decode_pos(pos: int, is_upper: bool) -> str:
    """Devuelve el carácter del alfabeto en la posición pos, con el case pedido."""
    ch = ALPHABET[pos]
    return ch if is_upper else ch.lower()

def sanitize_key(key: str) -> str:
    """Devuelve sólo las letras de la clave (A-Z), en la misma mezcla de cases."""
    return "".join([c for c in key if c.isalpha()])

def encrypt_vigenere(text: str, key: str) -> str:
    key = sanitize_key(key)
    if not key:
        raise ValueError("La clave debe contener al menos una letra.")
    result = []
    j = 0  # índice de la clave (avanza sólo cuando se cifra una letra)
    key_len = len(key)
    for ch in text:
        idx = index_of(ch)
        if idx != -1:
            key_idx = index_of(key[j % key_len])
            newpos = (idx + key_idx) % ALPHABET_LEN
            result.append(decode_pos(newpos, ch.isupper()))
            j += 1
        else:
            result.append(ch)
    return "".join(result)

def decrypt_vigenere(text: str, key: str) -> str:
    key = sanitize_key(key)
    if not key:
        raise ValueError("La clave debe contener al menos una letra.")
    result = []
    j = 0
    key_len = len(key)
    for ch in text:
        idx = index_of(ch)
        if idx != -1:
            key_idx = index_of(key[j % key_len])
            newpos = (idx - key_idx) % ALPHABET_LEN
            result.append(decode_pos(newpos, ch.isupper()))
            j += 1
        else:
            result.append(ch)
    return "".join(result)

def vinegere_menu():
    print("=== Cifrado Vigenère ===")
    print("1. Cifrar")
    print("2. Descifrar")
    opcion = input("Seleccione una opción (1 o 2): ").strip()
    texto = input("Ingrese el texto: ")
    clave = input("Ingrese la clave (solo letras, otros caracteres serán ignorados en la clave): ")

    try:
        if opcion == "1":
            cifrado = encrypt_vigenere(texto, clave)
            print("\nTexto cifrado:", cifrado)
        elif opcion == "2":
            descifrado = decrypt_vigenere(texto, clave)
            print("\nTexto descifrado:", descifrado)
        else:
            print("Opción inválida.")
    except ValueError as e:
        print("Error:", e)

def kasiski_menu():
    print("=== Kasiski (no implementado) ===")
    print("En el código original la opción Kasiski estaba vacía. Si quieres, puedo implementar")
    print("el método Kasiski para análisis de frecuencias / estimar longitud de clave.")

def main():
    print("=== Práctica 2 ===")
    print("1. Vigenère")
    print("2. Kasiski")
    opcion = input("Seleccione una opción (1 o 2): ").strip()
    if opcion == "1":
        vinegere_menu()
    elif opcion == "2":
        kasiski_menu()
    else:
        print("Opción inválida.")

if __name__ == "__main__":
    main()

#!/usr/bin/env python3
# cifrado_vigenere_kasiski.py
# Vigenère + examen de Kasiski (adaptado desde C a Python)

from collections import defaultdict

ALFABETO_MAY = list("ABCDEFGHIJKLMNOPQRSTUVWXYZ")
ALFABETO_MIN = list("abcdefghijklmnopqrstuvwxyz")
LONGITUD_ALFABETO = len(ALFABETO_MAY)  # 26

MAX_DIVISOR_CHECK = 25
MIN_SUB_L = 3
MAX_SUB_L = 5
MAX_KEY_SUGGESTIONS = 5

# ----------------- Vigenère -----------------

def codificar_caracter(c):
    if c in ALFABETO_MAY:
        return ALFABETO_MAY.index(c)
    if c in ALFABETO_MIN:
        return ALFABETO_MIN.index(c)
    return -1

def decodificar_posicion(pos, es_mayuscula):
    if pos < 0 or pos >= LONGITUD_ALFABETO:
        return '?'
    return ALFABETO_MAY[pos] if es_mayuscula else ALFABETO_MIN[pos]

def filtrar_clave(clave):
    """Devuelve la clave filtrada manteniendo solo letras válidas del alfabeto."""
    filtrada = [ch for ch in clave if codificar_caracter(ch) != -1]
    return ''.join(filtrada)

def cifrar_vigenere(texto, clave):
    clave_filtrada = filtrar_clave(clave)
    if not clave_filtrada:
        print("La clave no contiene letras válidas del alfabeto. Operación abortada.")
        return texto

    resultado = []
    j = 0
    clave_len = len(clave_filtrada)

    for ch in texto:
        cod = codificar_caracter(ch)
        clave_cod = codificar_caracter(clave_filtrada[j % clave_len])
        if cod != -1 and clave_cod != -1:
            nueva = (cod + clave_cod) % LONGITUD_ALFABETO
            es_may = ch.isupper()
            resultado.append(decodificar_posicion(nueva, es_may))
            j += 1
        else:
            resultado.append(ch)
    return ''.join(resultado)

def descifrar_vigenere(texto, clave):
    clave_filtrada = filtrar_clave(clave)
    if not clave_filtrada:
        print("La clave no contiene letras válidas del alfabeto. Operación abortada.")
        return texto

    resultado = []
    j = 0
    clave_len = len(clave_filtrada)

    for ch in texto:
        cod = codificar_caracter(ch)
        clave_cod = codificar_caracter(clave_filtrada[j % clave_len])
        if cod != -1 and clave_cod != -1:
            nueva = (cod - clave_cod + LONGITUD_ALFABETO) % LONGITUD_ALFABETO
            es_may = ch.isupper()
            resultado.append(decodificar_posicion(nueva, es_may))
            j += 1
        else:
            resultado.append(ch)
    return ''.join(resultado)

# ----------------- Kasiski -----------------

def construir_texto_filtrado(texto):
    """Solo letras, normalizadas a MAYÚSCULAS del alfabeto definido."""
    out = []
    for c in texto:
        idx = codificar_caracter(c)
        if idx != -1:
            out.append(ALFABETO_MAY[idx])
    return ''.join(out)

def kasiski_examination(texto):
    filtrado = construir_texto_filtrado(texto)
    n = len(filtrado)
    if n < MIN_SUB_L:
        print("Texto filtrado muy corto para examen Kasiski (menos de 3 letras).")
        return

    contador_divisores = [0] * (MAX_DIVISOR_CHECK + 1)
    total_repeticiones = 0

    print("\n--- Examen de Kasiski ---")
    print("Texto filtrado (solo letras, MAYÚSCULAS):")
    print(filtrado + "\n")

    for L in range(MIN_SUB_L, MAX_SUB_L + 1):
        found_any_for_L = False
        for i in range(0, n - L + 1):
            sub = filtrado[i:i+L]
            posiciones = [j for j in range(i, n - L + 1) if filtrado[j:j+L] == sub]
            if len(posiciones) > 1:
                # evitar repetir la misma subcadena varias veces desde otras i
                # sólo procesamos cuando la primera aparición coincide con i
                if posiciones[0] != i:
                    continue
                found_any_for_L = True
                total_repeticiones += 1
                print(f"Subcadena '{sub}' (long {L}) encontrada en posiciones: {', '.join(map(str,posiciones))}")
                distances = [posiciones[k] - posiciones[k-1] for k in range(1, len(posiciones))]
                print("  Distancias:", ", ".join(map(str, distances)))
                for dist in distances:
                    for div in range(2, MAX_DIVISOR_CHECK+1):
                        if dist % div == 0:
                            contador_divisores[div] += 1
                print()
        # fin for i
    if total_repeticiones == 0:
        print("No se encontraron subcadenas repetidas de longitud 3..5.")
        return

    print("--- Conteo de divisores (posibles longitudes de clave) ---")
    max_count = 0
    for div in range(2, MAX_DIVISOR_CHECK+1):
        if contador_divisores[div] > 0:
            print(f"Divisor {div:2d} : {contador_divisores[div]}")
            if contador_divisores[div] > max_count:
                max_count = contador_divisores[div]

    if max_count == 0:
        print("No se encontraron divisores frecuentes.")
        return

    # sugerencias: tomar los divisores más frecuentes
    suggestions = []
    copia = contador_divisores[:]
    for _ in range(MAX_KEY_SUGGESTIONS):
        best = max(range(2, MAX_DIVISOR_CHECK+1), key=lambda d: copia[d])
        if copia[best] == 0:
            break
        suggestions.append((best, copia[best]))
        copia[best] = 0

    print("\nSugerencias (posibles longitudes de clave) ordenadas por frecuencia:")
    for i, (l, cnt) in enumerate(suggestions, 1):
        print(f"  {i}) longitud {l} (conteo {cnt})")

    print("\nNota: Kasiski sugiere longitudes probables; confirma con análisis de frecuencia por columna o probando claves.\n")

# ----------------- Menús -----------------

def menu_vigenere():
    print("\n=== Modo Vigenère ===")
    print("1. Cifrar")
    print("2. Descifrar")
    opcion = input("Seleccione una opción (1 o 2): ").strip()
    if opcion not in ("1","2"):
        print("Opción inválida.")
        return

    texto = input("Ingrese el texto: ")
    clave = input("Ingrese la clave (solo letras): ")
    if opcion == "1":
        res = cifrar_vigenere(texto, clave)
        print("\nTexto cifrado:\n" + res)
    else:
        res = descifrar_vigenere(texto, clave)
        print("\nTexto descifrado:\n" + res)

def menu_kasiski():
    print("\n=== Modo Kasiski (examen) ===")
    texto = input("Ingrese el texto cifrado (se usarán solo letras):\n")
    kasiski_examination(texto)
    clave = input("Ingrese la clave tentativa: ")
    resultado = descifrar_vigenere(texto, clave)
    print(f"\nResultado del descifrado con clave '{clave}':\n{resultado}")


def main():
    print("=== Práctica: Vigenère + Kasiski (Python) ===")
    print("1. Vigenère")
    print("2. Kasiski")
    opcion = input("Seleccione una opción (1 o 2): ").strip()
    if opcion == "1":
        menu_vigenere()
    elif opcion == "2":
        menu_kasiski()
    else:
        print("Opción inválida.")

if __name__ == "__main__":
    main()