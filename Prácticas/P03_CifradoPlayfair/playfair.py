# -*- coding: utf-8 -*-
"""playfair.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e45Dswm7J_CYSjtBGn2KiU4SjurR0RYx
"""

##################### Cifrado
# Función para convertir la cadena a minúsculas
def toLowerCase(plain):
    n = len(plain)
    result = ""
    for i in range(n):
        if 64 < ord(plain[i]) < 91:
            result += chr(ord(plain[i]) + 32)
        else:
            result += plain[i]
    return result

# Función para eliminar todos los espacios en una cadena
def removeSpaces(plain):
    n = len(plain)
    temp = ""
    for i in range(n):
        if plain[i] != ' ':
            temp += plain[i]
    return temp

# Función para generar el cuadrado clave de 5x5
def generateKeyTable(key, keyT):
    n = len(key)

    keyT.clear()
    for i in range(5):
        keyT.append([0]*5)

    hashMap = [0]*26

    for i in range(n):
        if key[i] != 'j':
            hashMap[ord(key[i]) - 97] = 2

    hashMap[ord('j') - 97] = 1

    i = 0
    j = 0

    for k in range(n):
        if hashMap[ord(key[k]) - 97] == 2:
            hashMap[ord(key[k]) - 97] -= 1
            keyT[i][j] = key[k]
            j += 1
            if j == 5:
                i += 1
                j = 0

    for k in range(26):
        if hashMap[k] == 0:
            keyT[i][j] = chr(k + 97)
            j += 1
            if j == 5:
                i += 1
                j = 0

# Función para buscar los caracteres de un dígrafo
# en la casilla clave y devolver su posición
def search(keyT, a, b, arr):
    if a == 'j':
        a = 'i'
    if b == 'j':
        b = 'i'

    for i in range(5):
        for j in range(5):
            if keyT[i][j] == a:
                arr[0] = i
                arr[1] = j
            elif keyT[i][j] == b:
                arr[2] = i
                arr[3] = j

# Función para hacer que la longitud del texto simple sea uniforme
def prepare(string):
    if len(string) % 2 != 0:
        string += 'z'
    return string

# Función para realizar el cifrado
def encrypt(string, keyT):
    n = len(string)
    arr = [0]*4

    result = list(string)
    for i in range(0, n, 2):
        search(keyT, result[i], result[i+1], arr)

        if arr[0] == arr[2]:
            result[i] = keyT[arr[0]][(arr[1] + 1) % 5]
            result[i+1] = keyT[arr[0]][(arr[3] + 1) % 5]
        elif arr[1] == arr[3]:
            result[i] = keyT[(arr[0] + 1) % 5][arr[1]]
            result[i+1] = keyT[(arr[2] + 1) % 5][arr[1]]
        else:
            result[i] = keyT[arr[0]][arr[3]]
            result[i+1] = keyT[arr[2]][arr[1]]

    return ''.join(result)

# Función para cifrar usando Playfair Cipher
def encryptByPlayfairCipher(string, key):
    keyT = []
    key = toLowerCase(removeSpaces(key))
    string = toLowerCase(removeSpaces(string))
    string = prepare(string)
    generateKeyTable(key, keyT)
    return encrypt(string, keyT)

##################### Descifrado
# Función para convertir la cadena a minúsculas
def toLowerCase2(plain):
    plain = list(plain)
    for i in range(len(plain)):
        if ord(plain[i]) > 64 and ord(plain[i]) < 91:
            plain[i] = chr(ord(plain[i]) + 32)
    return ''.join(plain)

# Función para eliminar todos los espacios en una cadena
def removeSpaces2(plain):
    return ''.join([c for c in plain if c != ' '])

# Función para generar el cuadrado clave de 5x5
def generateKeyTable2(key, keyT):
    n = len(key)

    keyT[:] = [['' for _ in range(5)] for _ in range(5)]

    hashArr = [0] * 26

    for i in range(n):
        if key[i] != 'j':
            hashArr[ord(key[i]) - 97] = 2

    hashArr[ord('j') - 97] = 1

    i = j = 0

    for k in range(n):
        if hashArr[ord(key[k]) - 97] == 2:
            hashArr[ord(key[k]) - 97] -= 1
            keyT[i][j] = key[k]
            j += 1
            if j == 5:
                i += 1
                j = 0

    for k in range(26):
        if hashArr[k] == 0:
            keyT[i][j] = chr(k + 97)
            j += 1
            if j == 5:
                i += 1
                j = 0

# Función para descifrar
def decrypt(string, keyT):
    n = len(string)
    string = list(string)
    arr = [0] * 4
    for i in range(0, n, 2):
        search(keyT, string[i], string[i + 1], arr)
        if arr[0] == arr[2]:
            string[i] = keyT[arr[0]][(arr[1] - 1 + 5) % 5]
            string[i + 1] = keyT[arr[0]][(arr[3] - 1 + 5) % 5]
        elif arr[1] == arr[3]:
            string[i] = keyT[(arr[0] - 1 + 5) % 5][arr[1]]
            string[i + 1] = keyT[(arr[2] - 1 + 5) % 5][arr[1]]
        else:
            string[i] = keyT[arr[0]][arr[3]]
            string[i + 1] = keyT[arr[2]][arr[1]]
    return ''.join(string)

# Función para llamar a descifrar
def decryptByPlayfairCipher(string, key):
    keyT = []
    key = removeSpaces2(key)
    key = toLowerCase2(key)
    string = toLowerCase2(string)
    string = removeSpaces2(string)
    generateKeyTable2(key, keyT)
    return decrypt(string, keyT)

##################### Programa principal
def menu_cifrado():
    print("\n=== Cifrado Playfair ===")
    key = input("Ingrese la clave: ")
    string = input("Ingrese el texto a cifrar: ")
    cipher = encryptByPlayfairCipher(string, key)
    print("Texto cifrado:", cipher)

def menu_descifrado():
    print("\n=== Descifrado Playfair ===")
    key = input("Ingrese la clave: ")
    string = input("Ingrese el texto a descifrar: ")
    cipher = decryptByPlayfairCipher(string, key)
    print("Texto cifrado:", cipher)

def main():
    print("=== Práctica: Wheastone/Playfair (Python) ===")
    print("1. Cifrar")
    print("2. Descifrar")
    opcion = input("Seleccione una opción (1 o 2): ").strip()
    if opcion == "1":
      menu_cifrado()
    elif opcion == "2":
      menu_descifrado()
    else:
      print("Opción inválida.")

if __name__ == "__main__":
    main()